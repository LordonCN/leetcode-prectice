# 内存对齐
这样做的好处就是可以提高访问内存的速度,
使得总线的数据传输效率达到最高 --- 《深度探索cpp对象模型》

### 设已经有A,B,C,D4个类的定义，程序中A,B,C,D
析构函数调用顺序为？ A B D C  全局慢于静态变量

构造函数调用顺序为？ C A B D  全局最早

```c++
C c;
void main()
{
    A*pa=new A();
    B b;
    static D d;
    delete pa;
}

```

**64位系统 内存对齐 结构体大小计算**

### 内存对齐：它都要求内存分配的时候要对齐，这样做的好处就是可以提高访问内存的速度。

```c++
struct st_t {
    int status;
    short *pdata;
    char errstr[32];
};
```

- 32位环境  4字节对齐 指针占4字节
- 64位环境  8字节对齐 指针占8字节

因为是64位环境下
int status;虽然int只占用4个 由于后面的指针八个字节放不下 填补不了空位 所以对其要八个字节
short *pdata; 这个指针会占用8个字节
char errstr[32]; 占用32个字节
所以一共占用 8+8+32=48个字节
char *p=(char *)(st[2].errstr+32)，p实际指向了st[3]
则p-(char *)(st))，即为&st[3]-&st[0],占用空间为3个结构体的大小，即3*48=144，


```c++
// 64位系统中8个8个对齐
// 如果放不下那么就要把之前的补全对其
struct  X1 // 8
{
    int  i; // 4个字节
    char  c1; // 1个字节
    char  c2; // 1个字节
};

struct  X2 // 8+8+8
{
    char  c1; // 1个字节
    int * i; // 8个字节
    char  c2; // 1个字节
};

struct  X3 // 此处为8+8
{
    char * c1; // 8个字节
    char  c2; // 1个字节
    int  i; // 4个字节
};
```



