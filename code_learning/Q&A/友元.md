# 友元
**友元函数** 、 **友元类** 、 **友元成员函数**

- 为何需要友元：
因为重载的符号运算符只是对左右值为同种type来说的，不能应用于不同type之间。
用于解决例如 `ClassA = ClassB * 3.5;`这种奇怪的运算，或者`想直接获取类中私有变量信息`的时候 ,
这时候就需要定义友元函数.

- 友元特性：
不可传递 单向性 

#### 友元函数

```c++
class A{
public:
    A(int n){a_ = n;};
    A():a_(0){};
    ~A(){};
    void getNumber()const{cout<<a_<<endl;};
private:
    int a_;
    friend void function();// 全局function为A的友元
};
void function(){};
```

需要注意的是这个函数并不是类函数，但是他要有能操作类变量的能力，与成员函数权限相同。
`本质上`是类方法的一种接口，并不是违反了面向对象原则。



#### 友元成员函数

```c++
class A{
public:
    A(int n){a_ = n;};
    A():a_(0){};
    ~A(){};
    void getNumber()const{cout<<a_<<endl;};
private:
    int a_;
    friend void B::function();// 类B的function方法为A的友元
};
```


#### 友元类

可以通过友元函数直接调用参数 不用通过方法接口进行调用
```c++
class A{
public:
    A(int n){a_ = n;};
    A():a_(0){};
    ~A(){};
    void getNumber()const{cout<<a_<<endl;};
private:
    int a_;
    friend class B;
};

class B{
public:
    B(){};
    ~B(){};
    void changeA(A& a){a.a_ = 10;};// 友元类可以直接对A私有变量进行操作
};

int main()
{
    A a;
    a.getNumber();
    B b;
    b.changeA(a);
    a.getNumber();
    return 0;
}

```













