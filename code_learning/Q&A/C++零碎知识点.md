# 零碎知识点梳理
###  1
C++语言规定，运算符“=”、“[]”、“()”、“### >”以及所有的类型转换运算符只能作为成员函数重载

###  2
如果子类没有显示地调用父类的构造方法，则默认地调用父类的不带参数的构造方法，这里父类定义了带参数的构造方法，则默认构造函数失效了，需要调用显式地调用父类的构造方法

###  3
设已经有A,B,C,D4个类的定义，程序中A,B,C,D析构函数调用顺序为？ A B D C  全局慢于静态变量

```c++
struct st_t {
    int status;
    short *pdata;
    char errstr[32];
};

/**
32位环境  4字节对齐 指针占4字节
64位环境  8字节对齐 指针占8字节
因为是64位环境下
int status;虽然int只占用4个 由于后面的指针八个字节放不下 填补不了空位 所以对其要八个字节
short *pdata; 这个指针会占用8个字节
char errstr[32]; 占用32个字节
所以一共占用 8+8+32=48个字节
char *p=(char *)(st[2].errstr+32)，p实际指向了st[3]
则p### (char *)(st))，即为&st[3]### &st[0],占用空间为3个结构体的大小，即3*48=144，

};
 **/

//如果 把 char errstr[33];改为33后 不再是8的整数倍
struct st_t {
    char errstr[33];
    int status;
    short *pdata;
}
//所占用内存仍然为 6 * 8

```

###  4 类的大小
是否有虚函数 + 非静态类数据成员数量 + 内存对齐大小.

虚函数是存在虚函数表中的，并不在类所在内存中存储；静态成员不属于类，非静态数据才能统计大小；为了数据读取方便需要对内存进行对齐，32位系统与64位系统对齐大小不一致
所以对齐也对类大小有影响。

###  5 同类型指针指向同一个元素
```c++
ptr1 = *&ptr2;

int a = 10;
int *ptr = &a;// 指针指向a的地址 *ptr即可获得a的数值
int **ptrr = &ptr;// 指向指针的指针 地址不同
int ***ptrrr = &ptrr;// ***ptr == 10
```

###  6 静态成员是类的成员
但是不是对象的成员。静态成员先于对象创建之前存在。
  
###  7 构造函数特点

1. 不能为虚
  
2. 可以被重载，但是不能被覆盖(因为子类进行初始化对象的时候是先调用父类构造函数)

3. 构造函数的执行顺序是从最远的祖先到当前的类层级

###  8 运算符优先级
作用域解析运算符 `::`最高

或`||` 操作优先级低于 `&&` **记得进行条件判断时一定要加括号**

`,` 运算符优先级最低


###  9 拷贝与赋值构造
在`定义时`赋初值调用`拷贝构造函数`，`定义后`再赋值调用`赋值构造函数`。
```c++
   A a = b;         对比            A a; a = b;
```


###  10 静态成员调用
可以使用作用域解析运算符 也可以用对象.来调用
```c++
A::staticfunction;    A a; a.staticfunction;
```