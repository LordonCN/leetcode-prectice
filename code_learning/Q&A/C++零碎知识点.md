# 零碎知识点梳理
###  1
Cf+语言规定，运算符“=”、“[]”、“()”、“ >”以及所有的类型转换运算符只能作为成员函数重载

###  2
如果子类没有显示地调用父类的构造方法，则默认地调用父类的不带参数的构造方法，这里父类定义了带参数的构造方法，则默认构造函数失效了，需要调用显式地调用父类的构造方法

###  3
设已经有A,B,C,D4个类的定义，程序中A,B,C,D析构函数调用顺序为？ A B D C  全局慢于静态变量

###  4 类的大小
是否有虚函数 + 非静态类数据成员数量 + 内存对齐大小.

虚函数是存在虚函数表中的，并不在类所在内存中存储；静态成员不属于类，非静态数据才能统计大小；为了数据读取方便需要对内存进行对齐，32位系统与64位系统对齐大小不一致
所以对齐也对类大小有影响。

```c++
struct st_t {
    int status;
    short *pdata;
    char errstr[32];
};

/**
32位环境  4字节对齐 指针占4字节
64位环境  8字节对齐 指针占8字节
因为是64位环境下
int status;虽然int只占用4个 由于后面的指针八个字节放不下 填补不了空位 所以对其要八个字节
short *pdata; 这个指针会占用8个字节
char errstr[32]; 占用32个字节
所以一共占用 8+8+32=48个字节
char *p=(char *)(st[2].errstr+32)，p实际指向了st[3]
则p### (char *)(st))，即为&st[3]### &st[0],占用空间为3个结构体的大小，即3*48=144，

};
 **/

//如果 把 char errstr[33];改为33后 不再是8的整数倍
struct st_t {
    char errstr[33];
    int status;
    short *pdata;
}
//所占用内存仍然为 6 * 8

```
###  5 同类型指针指向同一个元素
```c++
ptr1 = *&ptr2;

int a = 10;
int *ptr = &a;// 指针指向a的地址 *ptr即可获得a的数值
int **ptrr = &ptr;// 指向指针的指针 地址不同
int ***ptrrr = &ptrr;// ***ptr == 10
```

###  6 静态成员是类的成员
但是不是对象的成员。
静态成员先于对象创建之前存在。
所有实例共享同一个static变量 ，通过类和对象都可以进行访问

  
###  7 构造函数特点
1. 不能为虚
2. 可以被重载，但是不能被覆盖(因为子类进行初始化对象的时候是先调用父类构造函数)
3. 构造函数的执行顺序是从最远的祖先到当前的类层级

###  8 运算符优先级
作用域解析运算符 `::`最高

或`||` 操作优先级低于 `&&` **记得进行条件判断时一定要加括号**

`,` 运算符优先级最低

###  9 拷贝与赋值构造
1. 在`定义时`赋初值调用`拷贝构造函数`，`定义后`再赋值调用`赋值构造函数`。
```c++
   A a = b;         对比           A a; a = b;
```
子类构造函数默认调用父类无参构造函数，如果父类没有定义那么必须显示调用父类构造函数或者重定义。
2. 函数调用作为形参时也是`拷贝构造函数` [牛客补充]
```c++
void print(B b){}
int main()
{
    B b; print(b);// 这里调用了B的拷贝构造函数，默认情况下是返回this
}
```

###  10 静态成员调用
可以使用作用域解析运算符 也可以用对象.来调用
```c++
A::staticfunction;    
A a; 
a.staticfunction;
```

###  11 向上转化两种方法
```c++
Father *fat = &son;// 指针类型赋值必须取地址
Father &fat = son;// 引用类型可直接赋值
```

###  12 linux执行命令后返回值
返回0 (惊不惊喜意不意外)


###  13 宏定义替换性
宏定义不是个函数，传入的参数并不是计算完毕后返回，而是将使用到的地方`完全替换`，所以存在事与愿违的情况，解决办法就是:
- `加括号`
```c++
#define hong(a) ((a)-(a*3))
```

###  14 头文件中：#ifndef  #endif
如果未定义 那么就定义 这里使用的是预编译指令 防止include过程重复调用.

`#include`的作用就是将包含的声明添加到程序的头部位置，在编译过程中会将源文件部分进行替换，得到临时文件。

编译器接受临时文件，

如果不加上这个宏判断就会使得头文件include的时候如果发生相互包含的情况就会反复调用出现问题。

###  15 有关于floor ceil round
```c++
    cout<<round(-5.5001)<<endl;// round +0.5 取floor 四舍五入
    cout<<floor(5.49)<<endl;// 向下取整
    cout<<ceil(5.1009)<<endl;// 向上取整
```

###  16 数组遍历
```c++
a[3][4];
a[1][2] == *(*(a+1)+2)// 二维数组的遍历方式可选
```

###  17 生成随机数
```c++
    random_device goal_rd;// 
    mt19937 goal_gen;// 生成随机的无符号整数
    uniform_int_distribution<int> goal_dis;

    goal_rd(goal_gen) --> float >0
    goal_dis(goal_gen) --> 0~9 (int)

```

### 18 为什么构造函数不能为虚函数
派生类的构造函数在基类之后定义，且其虚函数表继承自基类。
如果构造函数为虚函数那么不会继承基类的虚函数表，矛盾。


### 19 为什么析构函数建议为虚函数
当析构函数为虚时调用派生类析构函数能同时将基类释放掉，所以设置为虚函数。


### 20 复杂度比较

  O(1) < O(logn) < O(n) < O(nlogn) <...


### 21 数组索引的问题
对于a[3][4], 特别注意 带取引用的符号使得本来`从左到右`的遍历变成了`从上到下`.
```c++
*(&a[1]+1) == a[2][0]
*(&a[0][0]+5) == a[1][1]

*a == a[0][0]
*(a[1]+1)  == a[1][1]
*(*(a+1)+1) == a[1][1]
```

### 22 const相关：
1、形参不为引用且不希望在调用过程中改变其值 在括号内加const
    returnType funcname(const int a){}
2、形参为引用时不希望在调用过程中改变其值一般在开头与结尾添加两个const
    const returnType funcname(vector<int> &a)const{}

### 23 策略模式 [csdn](https://blog.csdn.net/qq_24649627/article/details/115491398)
* 基类定义虚函数接口
* 派生类继承后重写接口实现
* 使用另一个类对算法switchcase进行选择后new出来策略对象

### 24 模版模式 [csdn](https://blog.csdn.net/qq_24649627/article/details/115492148)
* 基类定义该模版统一接口及调用具体步骤流程接口
* 派生类重写步骤执行接口
* new新的对象直接调用构造函数

