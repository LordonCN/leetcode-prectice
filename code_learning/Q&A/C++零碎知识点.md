# 零碎知识点梳理
- 1
C++语言规定，运算符“=”、“[]”、“()”、“->”以及所有的类型转换运算符只能作为成员函数重载

- 2
如果子类没有显示地调用父类的构造方法，则默认地调用父类的不带参数的构造方法，这里父类定义了带参数的构造方法，则默认构造函数失效了，需要调用显式地调用父类的构造方法

- 3
设已经有A,B,C,D4个类的定义，程序中A,B,C,D析构函数调用顺序为？ A B D C  全局慢于静态变量

```c++
struct st_t {
    int status;
    short *pdata;
    char errstr[32];
};

/**
32位环境  4字节对齐 指针占4字节
64位环境  8字节对齐 指针占8字节
因为是64位环境下
int status;虽然int只占用4个 由于后面的指针八个字节放不下 填补不了空位 所以对其要八个字节
short *pdata; 这个指针会占用8个字节
char errstr[32]; 占用32个字节
所以一共占用 8+8+32=48个字节
char *p=(char *)(st[2].errstr+32)，p实际指向了st[3]
则p-(char *)(st))，即为&st[3]-&st[0],占用空间为3个结构体的大小，即3*48=144，

};
 **/

//如果 把 char errstr[33];改为33后 不再是8的整数倍
struct st_t {
    char errstr[33];
    int status;
    short *pdata;
}
//所占用内存仍然为 6 * 8

```

- 4 



