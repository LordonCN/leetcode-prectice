
什么是类型安全？
类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。
C++不是类型安全的语言，比如reinterpret可以对两种类型不同的指针进行强制转化。

为什么说 C++ 的四种命名类型转换比旧式转换更安全？
C中的指针转换永远都是保持指针指向地址不变，只改变指针类型，因此C中的C-Cast其实是没有歧义的。(这里的C-Cast指的是括号强制转化(int))
但在C++中，指针之间的自动转换存在一种特殊情况：如果将子类指针转向基类指针类型，这时候有可能需要调整指针指向的地址，尤其是多继承的情况下。
但是，也有可能用户就是想要旧式的强制改变类型而不改变值的特性，使用C-Cast就会比较麻烦，而且如果用户想要子类基类转换，却不小心搞错了继承关系，也会自动变成reinterpret_cast，这样还不如将这两种可能的转换方式分开，指针强制转换用reinterpret_cast表示，基类子类转换用static_cast表示，这样如果指针之间没有基类子类关系而用了static_cast就能正确提示编译错误，也避免了语义上的歧义。
C++比起C来说大大增强了const的作用，也允许const常量参与编译器优化，因而也需要对const修饰进行更强的保护。C-Cast可以自由去掉const限制，而在许多情况下去掉const修饰都是很危险的，实际使用中也很少出现，所以将涉及const的转换单独分离出去，保证了不会在不注意的时候不小心丢掉const修饰。C++新引入了从基类指针向子类指针转换的功能，这种转换同样需要调整指向的地址，但跟子类向基类转换还有不同，首先基类指针不一定是子类指针，其次涉及到虚基类的时候，两个指针之间的相对偏移是不固定的，跟实际的类型有关系，这样static_cast只能处理确信基类指针是子类指针且不涉及虚继承的情况。
C++需要引入一套基于运行时类型检查进行cast的方法，而且这种cast机制跟老的static_cast有歧义，所以需要引入一种新的dynamic_cast。总结来说，新的四种转换语法主要是为了保证转换语义无歧义。
————————————————
