# 面型对象五大设计原则：
开闭原则、
里氏替换原则、
依赖倒置原则、
单一职责原则、
接口隔离原则。

# 面向对象三大特性

### 继承 (公有继承、私有继承、保护继承 --> 正好是类中的三种类型)
**公有继承**(普通、多态、抽象)
继承通过使用已有的基类定义新的派生类，使得能够根据需要来对派生类进行修改。公有继承意味着派生类对象也应该是某种基类对象.
 
派生类继承基类的`数据成员与大部分方法`，但不能继承基类的`构造函数` `析构函数` `赋值运算符`及`友元`函数,
这里指的是不能够被取代，因为初始化子类对象会`先初始化父类`，`再初始化子类`。下面这个例子说明了继承类one创建之前先创建base，将base放到了one对象存储地址内，
可以通过作用域解析运算符调用。

```c++
class base{
public:
    base(){cout<<"hello i am base"<<endl;};// 初始化子类也会执行
    virtual ~base(){cout<<"i am base ~"<<endl;};// 初始化子类也会执行
    void getNumber(){cout<<number<<endl;};
private:
    int number = 1;
};

class one : public base{
public:
    one(){cout<<"123"<<endl;};
    ~one(){cout<<"i am ~one"<<endl;};
//    void getNumber(){cout<<number<<endl;};
private:
    int number = 11;// 重定义之后才能访问自己属性
};

int main()
{
    one o;// 初始化子类
    o.getNumber();// 默认调用父类方法访问父类私有变量
    // 程序结束 先析构子类 再析构父类
    return 0;
}
```
派生类能够直接`访问基类`的公有成员与保护成员，并能够通过基类的公有方法和保护方法访问基类的`私有成员`。// 父类与子类共有属性 肯定可以获取

可以再派生类中新增数据成员与方法，还可以将派生类用作基类进行进一步开发。

每个派生类都必须要有自己默认的构造函数，程序调用派生类的时候首`先调用基类的构造函数`，`然后调用派生类的`构造函数；
删除对象的时候首`先调用派生类的析构函数`，然后`调用基类的析构函数`。

- 基类的析构函数最好设置为`virtual`

##### 什么不能被继承？
构造函数 析构函数 赋值运算符 友元函数(非类函数)

**私有继承**
**保护继承**
两者相差不大

### 封装

### 多态
详情见[详细介绍](virtual_多态.md)
函数多态(运算符重载)、继承多态(父类指针指向子类)

直接表现形式：基类指针指向子类，调用共有方法时表现为子类形态,该方法多为虚方法。

1 对于含有虚函数的基类，派生出的子类构造完成之后可将引用赋值给父类指针(向上转化).
当基类有较多派生类的时候就会有如下情况：
```c++
    Worker * worker[n] = {&Singer,&Doctor,&Farmer,&Teacher};
```
使用基类指针来引用不同的对象体现出多态性。 即子类重写了父类的方法，虚函数表地址指向了子类。

2 无虚函数的公有继承中，子类对父类方法进行了重定义,初始化子类后经过向上转化使用父类指针时可实现多态。

```c++
class A {
private:
    int number;
public:
    A(int n):number(n){};
    ~A(){};
    void getNumber()const{cout<<number<<endl;};
}a_(10);


class B: public A{
public:
    B(int m):A(m){};// 调用父类构造函数即可

};

int main()
{
    B b_(11);
    a_.getNumber();
    b_.getNumber();
    A *aa_ = &b_;// 向上转化 
    aa_->getNumber();// 多态性验证 

    return 0;
}
```