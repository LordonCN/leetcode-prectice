# CPP三大特性

### 继承 (公有继承、私有继承、保护继承 --> 正好是类中的三种类型)
**公有继承**(普通、多态、抽象)
继承通过使用已有的基类定义新的派生类，是的能够根据需要来对派生类进行修改。 公有继承意味着派生类对象也应该是某种基类对象.
 
派生类继承积累的数据成员与大部分方法，但不能继承基类的`构造函数` `析构函数` `赋值运算符` 。

派生类能够直接`访问基类`的公有成员与保护成员，并能够通过基类的公有方法和保护方法访问基类的`私有成员`。

可以再派生类中新增数据成员与方法，还可以将派生类用作基类进行进一步开发。

每个派生类都必须要自己的构造函数，程序调用派生类的时候首`先调用基类的构造函数`，`然后调用派生类的`构造函数；
删除对象的时候首`先调用派生类的析构函数`，然后`调用基类的析构函数`。

基类的析构函数最好设置为`virtual`

##### 什么不能被继承？
构造函数 析构函数 赋值运算符 友元函数(非类函数)


**私有继承**
**保护继承**
两者相差不大



### 封装



### 多态
函数多态(运算符重载)、继承多态(父类指针指向子类)

直接表现形式：基类指针指向子类，调用共有方法时表现为子类形态,该方法多为虚方法。


1 对于含有虚函数的基类，派生出的子类构造完成之后可将引用赋值给父类指针(向上转化).
当基类有较多派生类的时候就会有如下情况：
```c++
    Worker * worker[n] = {&Singer,&Doctor,&Farmer,&Teacher};
```
使用基类指针来引用不同的对象体现出多态性。 即子类重写了父类的方法，虚函数表地址指向了子类。

2 无虚函数的公有继承中，子类对父类方法进行了重定义,初始化子类后经过向上转化使用父类指针时可实现多态。

```c++
class A {
private:
    int number;
public:
    A(int n):number(n){};
    ~A(){};
    void getNumber()const{cout<<number<<endl;};
}a_(10);


class B: public A{
public:
    B(int m):A(m){};// 调用父类构造函数即可

};

int main()
{
    B b_(11);
    a_.getNumber();
    b_.getNumber();
    A *aa_ = &b_;// 向上转化 
    aa_->getNumber();// 多态性验证 

    return 0;
}
```