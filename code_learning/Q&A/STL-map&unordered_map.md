## vector底层map与unordered_map底层实现

[STL手册](http://www.cplusplus.com/reference/unordered_map/unordered_map/)  

`运行效率方面`：unordered_map最高，而map效率较低但提供了`稳定效率`和`有序的序列`。

`占用内存方面`：map内存占用略低，unordered_map内存占用略高,而且是线性成比例的。

`两者使用区别`：需要无序容器，快速查找删除，不担心略高的内存时用unordered_map；
有序容器稳定查找删除效率，内存很在意时候用map。

hashmap内部是一个hashtable,由一个大vector组成，每个空又叫做桶，vector元素节点可挂接链表来解决冲突，来实现。（但是调试过程中hash存储时并不连续）

- 原理：
map是通过重载<比较运算符来判断元素是否相同，进而插入到红黑树中，因为对map进行中序遍历得到的结果是有序的。
  
unordered_map 实现键值对存储时首先申请一个连续的vector空间，vector中存储链表的头指针，这些链表称为桶，通过hash值与桶数运算得到存储位置，创建新节点链接到桶上

- 解释问题： unordered_map 在存储过程中会变得无序？无序容器不能够顺序遍历
无序容器中，不仅用到hash函数进行存储位置计算，还会涉及负载因子的使用：
负载因子的计算方法为：负载因子 = 容器存储的总键值对 / 桶数

默认情况下，无序容器的最大负载因子为 1.0。如果在操作无序容器过程中最大复杂因子超过了默认值，则容器会自动增加桶数，并重新进行哈希，以此来减小负载因子的值。问题就发生在此过程会导致容器迭代器失效（乱序），但指向单个键值对的引用或者指针仍然有效。
这也就解释了，为什么我们在操作无序容器过程中，键值对的存储顺序有时会“莫名”的发生变动。


[参考](http://c.biancheng.net/view/7235.html) 

